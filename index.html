<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Audio Processing with EQ, Compressor & Progressbar</title>
  <style>
    #progressContainer {
      width: 100%;
      background-color: #ddd;
      margin-top: 20px;
      border-radius: 8px;
      overflow: hidden;
    }
    #progressBar {
      width: 0%;
      height: 24px;
      background-color: #4caf50;
      text-align: center;
      color: white;
      line-height: 24px;
      transition: width 0.2s;
    }
  </style>
</head>
<body>
  <h1>Concatenate Audio with Normalizer, EQ & Compressor</h1>
  Vocals: <input type="file" id="file1" accept="audio/*"><br><br>
  Instrumental: <input type="file" id="file2" accept="audio/*"><br><br>
  <h2>Pause (s)</h2>
  Pause: <input type="range" id="pause" min="0" max="10" value="3"><span id="pauseVal">3</span><br>
  
  <h2>EQ Settings (dB)</h2>
  Bass: <input type="range" id="bass" min="-12" max="12" value="0"><span id="bassVal">0</span><br>
  Mids: <input type="range" id="mid" min="-12" max="12" value="0"><span id="midVal">0</span><br>
  Highs: <input type="range" id="treble" min="-12" max="12" value="0"><span id="trebleVal">0</span><br><br>

  <h2>Kompressor Settings</h2>
  Threshold: <input type="range" id="threshold" min="-60" max="0" value="-24"><span id="thrVal">-24</span><br>
  Ratio: <input type="range" id="ratio" min="1" max="20" value="4"><span id="ratVal">4</span><br>
  Attack: <input type="range" id="attack" min="0" max="200" value="10"><span id="attVal">10</span><br>
  Release: <input type="range" id="release" min="50" max="2000" value="250"><span id="relVal">250</span><br>
  Makeup Gain: <input type="range" id="gain" min="-12" max="12" value="0"><span id="gainVal">0</span><br><br>

  <button onclick="process()">Process & Download MP3</button>

  <div id="progressContainer">
    <div id="progressBar">0%</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
  <script>
    // Slider-Anzeige binden
    function bindSlider(id, spanId, suffix="") {
      const slider = document.getElementById(id);
      const span = document.getElementById(spanId);
      slider.addEventListener("input", () => { span.textContent = slider.value + suffix; });
      span.textContent = slider.value + suffix;
    }
    bindSlider("pause","pauseVal"," s");
    bindSlider("bass","bassVal"," dB");
    bindSlider("mid","midVal"," dB");
    bindSlider("treble","trebleVal"," dB");
    bindSlider("threshold","thrVal"," dB");
    bindSlider("ratio","ratVal",":1");
    bindSlider("attack","attVal"," ms");
    bindSlider("release","relVal"," ms");
    bindSlider("gain","gainVal"," dB");

    function updateProgress(percent, text) {
      const bar = document.getElementById("progressBar");
      bar.style.width = percent + "%";
      bar.textContent = text + " (" + percent + "%)";
    }

    // Normalisierung auf 0 dB (1.0 peak)
    function normalizeBuffer(buffer) {
      const numCh = buffer.numberOfChannels;
      let peak = 0;
      for (let ch = 0; ch < numCh; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
          peak = Math.max(peak, Math.abs(data[i]));
        }
      }
      if (peak === 0) return buffer;
      const gain = 1 / peak;
      for (let ch = 0; ch < numCh; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
          data[i] *= gain;
        }
      }
      return buffer;
    }

    async function process() {
      updateProgress(0, "Starte...");

      const ctx = new AudioContext();
      async function loadFile(file) {
        const arrayBuffer = await file.arrayBuffer();
        return await ctx.decodeAudioData(arrayBuffer);
      }

updateProgress(10,"Dateien laden & normalisieren...");
const f1 = document.getElementById("file1").files[0];
const f2 = document.getElementById("file2").files[0];

if (!f1) { alert("Bitte mindestens eine Datei auswählen!"); return; }

const ctx = new AudioContext();
async function loadFile(file){
    const arrayBuffer = await file.arrayBuffer();
    return await ctx.decodeAudioData(arrayBuffer);
}

let buf1 = normalizeBuffer(await loadFile(f1));
let buf2 = f2 ? normalizeBuffer(await loadFile(f2)) : null;

let outBuffer;
let totalLength;
let pause = f2 ? ctx.sampleRate*3 : 0;

if(buf2){
    updateProgress(25,"Dateien zusammenfügen...");
    totalLength = buf1.length + pause + buf2.length;
    outBuffer = ctx.createBuffer(2,totalLength,ctx.sampleRate);

    for(let ch=0; ch<2; ch++){
        if(buf1.numberOfChannels>ch) outBuffer.getChannelData(ch).set(buf1.getChannelData(ch),0);
        if(buf2.numberOfChannels>ch) outBuffer.getChannelData(ch).set(buf2.getChannelData(ch), buf1.length + pause);
    }

    updateProgress(40,"EQ & Kompressor auf beide anwenden...");
}else{
    updateProgress(25,"Nur File1 vorhanden, EQ & Kompressor auf File1...");
    outBuffer = ctx.createBuffer(2, buf1.length, ctx.sampleRate);
    for(let ch=0; ch<2; ch++){
        if(buf1.numberOfChannels>ch) outBuffer.getChannelData(ch).set(buf1.getChannelData(ch),0);
    }
}

// Offline-Kontext für Effekte
const offlineCtx = new OfflineAudioContext(2, outBuffer.length, outBuffer.sampleRate);
const source = offlineCtx.createBufferSource();
source.buffer = outBuffer;

// EQ
const bass = offlineCtx.createBiquadFilter();
bass.type="lowshelf"; bass.frequency.value=200; bass.gain.value=parseFloat(document.getElementById("bass").value);

const mid = offlineCtx.createBiquadFilter();
mid.type="peaking"; mid.frequency.value=1000; mid.Q.value=1; mid.gain.value=parseFloat(document.getElementById("mid").value);

const treble = offlineCtx.createBiquadFilter();
treble.type="highshelf"; treble.frequency.value=3000; treble.gain.value=parseFloat(document.getElementById("treble").value);

// Kompressor
const comp = offlineCtx.createDynamicsCompressor();
comp.threshold.value=parseFloat(document.getElementById("threshold").value);
comp.ratio.value=parseFloat(document.getElementById("ratio").value);
comp.attack.value=parseFloat(document.getElementById("attack").value)/1000;
comp.release.value=parseFloat(document.getElementById("release").value)/1000;

// Makeup Gain
const gainNode = offlineCtx.createGain();
gainNode.gain.value=Math.pow(10,parseFloat(document.getElementById("gain").value)/20);

// Verkettung
source.connect(bass); bass.connect(mid); mid.connect(treble);
treble.connect(comp); comp.connect(gainNode); gainNode.connect(offlineCtx.destination);

source.start();
let processedBuffer = await offlineCtx.startRendering();

updateProgress(60,"End-Normalisierung...");
processedBuffer = normalizeBuffer(processedBuffer);


      updateProgress(70, "MP3-Encoding...");
      // WAV-Konvertierung
      function audioBufferToWav(buffer) {
        const numOfChan = buffer.numberOfChannels,
              length = buffer.length * numOfChan * 2 + 44,
              buffer2 = new ArrayBuffer(length),
              view = new DataView(buffer2),
              channels = [],
              sampleRate = buffer.sampleRate;
        let offset = 0;
        let pos = 0;

        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8);
        setUint32(0x45564157); // "WAVE"
        setUint32(0x20746d66); // "fmt "
        setUint32(16);
        setUint16(1);
        setUint16(numOfChan);
        setUint32(sampleRate);
        setUint32(sampleRate * 2 * numOfChan);
        setUint16(numOfChan * 2);
        setUint16(16);
        setUint32(0x61746164); // "data"
        setUint32(length - pos - 4);

        for (let i = 0; i < numOfChan; i++) {
          channels.push(buffer.getChannelData(i));
        }

        while (pos < length) {
          for (let i = 0; i < numOfChan; i++) {
            let sample = Math.max(-1, Math.min(1, channels[i][offset]));
            view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
            pos += 2;
          }
          offset++;
        }
        return buffer2;
      }

      // Float32 -> Int16 konvertieren
function floatTo16BitPCM(float32Array) {
  const output = new Int16Array(float32Array.length);
  for (let i = 0; i < float32Array.length; i++) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
  }
  return output;
}

const left = floatTo16BitPCM(processedBuffer.getChannelData(0));
const right = floatTo16BitPCM(processedBuffer.numberOfChannels > 1
                              ? processedBuffer.getChannelData(1)
                              : processedBuffer.getChannelData(0)); // Mono → duplizieren

const mp3encoder = new lamejs.Mp3Encoder(2, ctx.sampleRate, 128);
const mp3Data = [];

const blockSize = 1152;
for (let i = 0; i < left.length; i += blockSize) {
  const leftChunk = left.subarray(i, i + blockSize);
  const rightChunk = right.subarray(i, i + blockSize);

  const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
  if (mp3buf.length > 0) mp3Data.push(mp3buf);

  let percent = 70 + Math.round((i / left.length) * 25);
  updateProgress(percent, "MP3-Encoding...");
  await new Promise(r => setTimeout(r, 0)); // UI nicht blockieren
}

const mp3buf = mp3encoder.flush();
if (mp3buf.length > 0) mp3Data.push(mp3buf);


      const blob = new Blob(mp3Data, { type: "audio/mp3" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "output.mp3";
      a.click();

      updateProgress(100, "Fertig ✅");
    }
  </script>
</body>
</html>
