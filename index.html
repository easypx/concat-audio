<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Audio Tool</title>
<style>
  body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #eef1f5; color: #222; margin: 0; transition: background 0.3s, color 0.3s; }
  header { background: #4caf50; color: white; padding: 20px; text-align: center; font-size: 24px; position: relative; }
  main { max-width: 900px; margin: 20px auto; padding: 0 20px; }
  .tabs { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
  .tab-btn {
    padding: 12px 18px; border: none; border-radius: 8px;
    background: #ddd; cursor: pointer; font-size: 16px; transition: 0.3s;
  }
  .tab-btn.active { background: #4caf50; color: white; }
  .card {
    display: none; background: white; border-radius: 12px;
    padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    animation: fadein 0.4s ease; transition: background 0.3s, color 0.3s;
  }
  .card.visible { display: block; }
  @keyframes fadein { from {opacity:0; transform: translateY(10px);} to {opacity:1; transform: translateY(0);} }
  .control { margin: 12px 0; }
  label { display: inline-block; min-width: 140px; }
  input[type=range] { width: 300px; vertical-align: middle; }
  .value { margin-left: 10px; font-weight: bold; }
  button.action, .preset-btn {
    margin-top: 10px; padding: 10px 16px; border: none; border-radius: 8px;
    background: #4caf50; color: white; font-size: 14px; cursor: pointer;
  }
  button.action:hover, .preset-btn:hover { background: #45a049; }
  .preset-group { margin-top: 10px; }
  #progressContainer { width: 100%; background-color: #ddd; margin-top: 30px; border-radius: 8px; overflow: hidden; }
  #progressBar { width: 0%; height: 24px; background-color: #4caf50; text-align: center; color: white; line-height: 24px; transition: width 0.3s; }

  /* Dark Mode */
  body.dark { background: #1e1e1e; color: #eee; }
  body.dark header { background: #2e7d32; }
  body.dark .tab-btn { background: #333; color: #eee; }
  body.dark .tab-btn.active { background: #4caf50; color: white; }
  body.dark .card { background: #2a2a2a; color: #eee; box-shadow: 0 4px 12px rgba(0,0,0,0.6); }
  body.dark #progressContainer { background-color: #444; }
  body.dark #progressBar { background-color: #81c784; }

  /* Dark mode toggle */
  #darkToggle {
    position: absolute; right: 20px; top: 20px;
    background: #fff; color: #222; border: none; border-radius: 20px;
    padding: 6px 14px; cursor: pointer; transition: background 0.3s, color 0.3s;
  }
  body.dark #darkToggle { background: #444; color: #eee; }
</style>
</head>
<body>
<header>
  🎵 My Audio Tool
  <button id="darkToggle" onclick="toggleDark()">🌙 Dark</button>
</header>
<main>
  <div class="tabs">
    <button class="tab-btn active" onclick="showTab('voice')">Enhance Voice</button>
    <button class="tab-btn" onclick="showTab('merge')">Merge Audio</button>
  </div>

  <!-- Voice Enhancement -->
  <div id="voice" class="card visible">
    <h2>Enhance Voice</h2>
    <div class="control"><input type="file" id="voiceFile" accept="audio/*"></div>
    <div class="control"><label><input type="checkbox" id="enableEQ" checked> Apply EQ</label></div>
    <div class="control"><label><input type="checkbox" id="enableComp" checked> Apply Compressor</label></div>

    <h3>Presets</h3>
    <div class="preset-group">
      <button class="preset-btn" onclick="applyPreset('podcast')">Podcast</button>
      <button class="preset-btn" onclick="applyPreset('music')">Music</button>
      <button class="preset-btn" onclick="applyPreset('telephone')">Telephone Voice</button>
    </div>

    <h3>EQ Settings</h3>
    <div class="control"><label>Bass</label><input type="range" id="bass" min="-12" max="12" value="0"><span class="value" id="bassVal">0 dB</span></div>
    <div class="control"><label>Mid</label><input type="range" id="mid" min="-12" max="12" value="0"><span class="value" id="midVal">0 dB</span></div>
    <div class="control"><label>Treble</label><input type="range" id="treble" min="-12" max="12" value="0"><span class="value" id="trebleVal">0 dB</span></div>

    <h3>Compressor Settings</h3>
    <div class="control"><label>Threshold</label><input type="range" id="threshold" min="-60" max="0" value="-24"><span class="value" id="thrVal">-24 dB</span></div>
    <div class="control"><label>Ratio</label><input type="range" id="ratio" min="1" max="20" value="4"><span class="value" id="ratVal">4:1</span></div>
    <div class="control"><label>Attack</label><input type="range" id="attack" min="0" max="200" value="10"><span class="value" id="attVal">10 ms</span></div>
    <div class="control"><label>Release</label><input type="range" id="release" min="50" max="2000" value="250"><span class="value" id="relVal">250 ms</span></div>
    <div class="control"><label>Makeup Gain</label><input type="range" id="gain" min="-12" max="12" value="0"><span class="value" id="gainVal">0 dB</span></div>

    <button class="action" onclick="processVoice()">Process & Download MP3</button>
  </div>

  <!-- Audio Merge -->
  <div id="merge" class="card">
    <h2>Merge Audio</h2>
    <div class="control"><input type="file" id="mergeFile1" accept="audio/*"></div>
    <div class="control"><input type="file" id="mergeFile2" accept="audio/*"></div>
    <div class="control"><label>Pause</label><input type="range" id="pause" min="0" max="10" value="3"><span class="value" id="pauseVal">3 s</span></div>
    <button class="action" onclick="processMerge()">Process & Download MP3</button>
  </div>

  <!-- Progress -->
  <div id="progressContainer"><div id="progressBar">0%</div></div>
</main>

<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<script>
// Dark Mode
function toggleDark(){
  document.body.classList.toggle("dark");
  const btn = document.getElementById("darkToggle");
  if(document.body.classList.contains("dark")){
    btn.textContent = "☀️ Light";
  } else {
    btn.textContent = "🌙 Dark";
  }
}

// Tabs
function showTab(id){
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.card').forEach(c => c.classList.remove('visible'));
  document.querySelector(`.tab-btn[onclick="showTab('${id}')"]`).classList.add('active');
  document.getElementById(id).classList.add('visible');
}

// Slider bindings
function bindSlider(id, spanId, suffix="") {
  const slider = document.getElementById(id);
  const span = document.getElementById(spanId);
  slider.addEventListener("input", () => { span.textContent = slider.value + suffix; });
  span.textContent = slider.value + suffix;
}
bindSlider("bass","bassVal"," dB");
bindSlider("mid","midVal"," dB");
bindSlider("treble","trebleVal"," dB");
bindSlider("threshold","thrVal"," dB");
bindSlider("ratio","ratVal",":1");
bindSlider("attack","attVal"," ms");
bindSlider("release","relVal"," ms");
bindSlider("gain","gainVal"," dB");
bindSlider("pause","pauseVal"," s");

// Progress bar
function updateProgress(percent, text) {
  const bar = document.getElementById("progressBar");
  bar.style.width = percent + "%";
  bar.textContent = text + " (" + percent + "%)";
}

// Presets
function applyPreset(type){
  if(type==="podcast"){
    setValues({bass:3, mid:1, treble:2, threshold:-20, ratio:4, attack:10, release:250, gain:3});
  } else if(type==="music"){
    setValues({bass:5, mid:0, treble:4, threshold:-18, ratio:3, attack:15, release:300, gain:2});
  } else if(type==="telephone"){
    setValues({bass:-4, mid:5, treble:-2, threshold:-25, ratio:6, attack:5, release:200, gain:4});
  }
  // Ensure EQ and Compressor are enabled
  document.getElementById("enableEQ").checked = true;
  document.getElementById("enableComp").checked = true;
}
function setValues(obj){
  for(const id in obj){
    document.getElementById(id).value=obj[id];
    document.getElementById(id+"Val").textContent=obj[id]+
      (id==="threshold"?" dB":id==="ratio"?":1":id==="attack"||id==="release"?" ms":" dB");
  }
}

// Normalize helper
function normalizeBuffer(buffer) {
  const numCh = buffer.numberOfChannels;
  let peak = 0;
  for (let ch = 0; ch < numCh; ch++) {
    const data = buffer.getChannelData(ch);
    for (let i = 0; i < data.length; i++) peak = Math.max(peak, Math.abs(data[i]));
  }
  if (peak === 0) return buffer;
  const gain = 1/peak;
  for (let ch = 0; ch < numCh; ch++) {
    const data = buffer.getChannelData(ch);
    for (let i = 0; i < data.length; i++) data[i]*=gain;
  }
  return buffer;
}

// Float32 -> Int16
function floatTo16BitPCM(float32Array) {
  const output = new Int16Array(float32Array.length);
  for (let i = 0; i < float32Array.length; i++) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    output[i] = s<0 ? s*0x8000 : s*0x7FFF;
  }
  return output;
}

// MP3 export
async function exportMP3(buffer, sampleRate){
  const left = floatTo16BitPCM(buffer.getChannelData(0));
  const right = floatTo16BitPCM(buffer.numberOfChannels>1?buffer.getChannelData(1):buffer.getChannelData(0));
  const mp3encoder = new lamejs.Mp3Encoder(2, sampleRate, 128);
  const mp3Data = [];
  const blockSize=1152;
  for(let i=0;i<left.length;i+=blockSize){
    const leftChunk = left.subarray(i,i+blockSize);
    const rightChunk = right.subarray(i,i+blockSize);
    const mp3buf = mp3encoder.encodeBuffer(leftChunk,rightChunk);
    if(mp3buf.length>0) mp3Data.push(mp3buf);
    let percent = 70+Math.round((i/left.length)*25);
    updateProgress(percent,"Encoding MP3...");
    await new Promise(r=>setTimeout(r,0));
  }
  const mp3buf = mp3encoder.flush();
  if(mp3buf.length>0) mp3Data.push(mp3buf);

  const blob = new Blob(mp3Data,{type:"audio/mp3"});
  const url = URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="output.mp3"; a.click();
  updateProgress(100,"Done ✅");
}

// Voice processing
async function processVoice(){
  updateProgress(0,"Processing voice...");
  const f=document.getElementById("voiceFile").files[0];
  if(!f){alert("Please select a file!");return;}
  const ctx = new AudioContext();
  const arrayBuffer = await f.arrayBuffer();
  let buf = await ctx.decodeAudioData(arrayBuffer);
  buf = normalizeBuffer(buf);

  const offlineCtx = new OfflineAudioContext(2, buf.length, buf.sampleRate);
  const source = offlineCtx.createBufferSource();
  source.buffer = buf;

  let nodeChain = source;

  if(document.getElementById("enableEQ").checked){
    const bass = offlineCtx.createBiquadFilter();
    bass.type="lowshelf"; bass.frequency.value=200; bass.gain.value=parseFloat(document.getElementById("bass").value);
    const mid = offlineCtx.createBiquadFilter();
    mid.type="peaking"; mid.frequency.value=1000; mid.Q.value=1; mid.gain.value=parseFloat(document.getElementById("mid").value);
    const treble = offlineCtx.createBiquadFilter();
    treble.type="highshelf"; treble.frequency.value=3000; treble.gain.value=parseFloat(document.getElementById("treble").value);
    nodeChain.connect(bass); bass.connect(mid); mid.connect(treble); nodeChain = treble;
  }

  if(document.getElementById("enableComp").checked){
    const comp = offlineCtx.createDynamicsCompressor();
    comp.threshold.value=parseFloat(document.getElementById("threshold").value);
    comp.ratio.value=parseFloat(document.getElementById("ratio").value);
    comp.attack.value=parseFloat(document.getElementById("attack").value)/1000;
    comp.release.value=parseFloat(document.getElementById("release").value)/1000;
    const gainNode = offlineCtx.createGain();
    gainNode.gain.value=Math.pow(10,parseFloat(document.getElementById("gain").value)/20);
    nodeChain.connect(comp); comp.connect(gainNode); nodeChain = gainNode;
  }

  nodeChain.connect(offlineCtx.destination);
  source.start();
  let processed = await offlineCtx.startRendering();
  processed = normalizeBuffer(processed);
  await exportMP3(processed, ctx.sampleRate);
}

// Audio merge
async function processMerge(){
  updateProgress(0,"Merging audio...");
  const f1=document.getElementById("mergeFile1").files[0];
  const f2=document.getElementById("mergeFile2").files[0];
  if(!f1||!f2){alert("Please select two files!");return;}
  const ctx = new AudioContext();

  async function load(file){
    const ab = await file.arrayBuffer();
    return await ctx.decodeAudioData(ab);
  }

  let buf1 = normalizeBuffer(await load(f1));
  let buf2 = normalizeBuffer(await load(f2));

  const pauseSec = parseInt(document.getElementById("pause").value);
  const pause = ctx.sampleRate*pauseSec;
  const totalLength = buf1.length + pause + buf2.length;
  const outBuffer = ctx.createBuffer(2,totalLength,ctx.sampleRate);

  for(let ch=0;ch<2;ch++){
    if(buf1.numberOfChannels>ch) outBuffer.getChannelData(ch).set(buf1.getChannelData(ch),0);
    if(buf2.numberOfChannels>ch) outBuffer.getChannelData(ch).set(buf2.getChannelData(ch),buf1.length+pause);
  }

  const normalized = normalizeBuffer(outBuffer);
  await exportMP3(normalized, ctx.sampleRate);
}
</script>
</body>
</html>
